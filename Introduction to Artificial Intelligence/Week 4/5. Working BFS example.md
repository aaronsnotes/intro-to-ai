Previous: [[4. Uniformed Search Strategies]]

---
```python
import collections

#1. define node structure
class Node:
	def __init__(self, state, parent=None, action=None, path_cost=0):
		self.state = state #current position (row, col)
		self.parent = parent #previous node
		self.action = action #action taken to get here (e.g., "UP")
		self.path_cost = path_cost #steps taken so far
	
	def __repr__(self):
		return f"Node({self.state})"
	
	#helper to reconstruct the path from Goal -> Start
	def get_path(self):
		path = []
		node = self
		while node:
			path.append((node.state, node.action))
			node = node.parent
		return path[::1] #reverse to get Start -> Goal

#2. define the problem (grid navigation)
class GridProblem:
	def __init__(self, grid):
		self.grid = grid
		self.rows = len(grid)
		self.cols = len(grid[0])
		self.initial_state = self.find_position('S')
		self.goal_state = self.find_position('G')
	
	def find_position(self, char):
		for r in range(self.rows):
			for c in range(self.cols):
				if self.grid[r][c] == char:
					return (r, c)
		return None
	
	def is_goal(self, state):
		return state == self.goal_state
	
	def actions(self, state):
		#returns valid moves: UP, DOWN, LEFT, RIGHT
		r, c = state
		possible_actions = [
			("UP", (r - 1, c)),
			("DOWN", (r + 1, c)),
			("LEFT", (r, c - 1)),
			("RIGHT", (r, c + 1))
		]
		valid_actions = []
		for action_name, (nr, nc) in possible_actions:
			#check boundaries and obstacles ('#')
			if 0 <= nr < self.rows and 0 <= nc < self.cols and self.grid[nr][nc] != '#':
				valid_actions.append((action_name, (nr, nc)))
		return valid_actions

#3. the BFS algorithm
def breadth_first_search(problem):
	#create the root node
	node = Node(state=problem.initial_state)
	
	#check if start is already the goal
	if problem.is_goal(node.state):
		return node
	
	#initialise frontier (queue) with root node
	frontier = collections.deque([node])
	
	#initialise explored set to track visited states
	explored = set()
	
	print(f"Starting BFS from {node.start}...")
	
	while frontier:
		#POP: remove the shallowest node (FIFO)
		node = frontier.popleft()
		explored.add(node.state)
		
		#explore neighbours
		for action, next_state in problem.actions(node.state):
			#child node generation
			child = Node(state=next_state, parent=node, action=action, path_cost=path_cost + 1)
			
			#check if state has been visited or is already in frontier
			if child.state not in explored and child not in [n.state for n in frontier]:
				#goal test
				if problem.is_goal(child.state):
					return child
				
				#INSERT: add to back of queue
				frontier.append(child)
	
	return None #failure

#---main execution---
if __name__ == "__main__":
	#define simple grid map
	#S = start, G = goal, # = obstacle, . = open path
	grid_map = [
		['S', '.', '.', '#', '.'],
		['.', '#', '.', '#', '.'],
		['.', '.', '.', '.', '.'],
		['#', '.', '#', '#', '.'],
		['.', '.', '.', '#', 'G']
	]
	
	problem = GridProblem(grid_map)
	result_node = breadth_first_search(problem)
	
	if result_node:
		print(f"\nGoal found at {result_node.state}!")
		print(f"Path cost: {result_node.path_cost} steps")
		print("Path taken:")
		
		path = result_node.get_path()
		for step in path:
			state, action = step
			if action: #skip printing action for the start node
				print(f" -> Move {action} to {state}")
			else:
				print(f"Start at {state}")
	else:
		print("\nNo solution found. Sorry.")
```
---

Back to index: [[Intro to AI - Index]]