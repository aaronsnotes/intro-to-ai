Previous: [[1. Searching for Solutions]]

To implement search algorithms, we need specific data structures to manage the tree construction and the "frontier" of exploration.

# The node data structure
A node in the search tree is a data structure with specific components.

## Python implementation:
```python
class Node:
	def __init__(self, state, parent=None, action=None, path_cost=0):
		self.state = state #state in the state space
		self.parent = parent #the node that generated this node
		self.action = action #the action applied to parent to generate this
		self.path_cost = path_cost #cost from initial state to this node (g(n))
	
	def __repr__(self):
		return f"<Node {self.state}>"
```

# Child node generation
We need a function to create a new node from a parent based on an action.

## Python implementation
```python
def child_node(problem, parent, action):
	"""
	Generates new child node.
	problem.result(s, a) -> returns the next state
	problem.step_cost(s, a) -> returns the cost of the step
	"""
	next_state = problem.result(parent.state, action)
	new_cost = parent.path_cost + problem.step_cost(parent.state, action)
	
	return Node(state=next_state, parent=parent, action=action, path_cost=new_cost)
```

# The frontier
The **frontier** (or open list) is the set of all leaf nodes available for expansion. It is usually implemented as a Queue.

## Python implementation:
```python
from collections import deque

#FIFO Queue for Breadth First Search
frontier = deque()

#operations
frontier.append(node) #INSERT
if frontier: #EMPTY? check
	node = frontier.popleft() #POP
```

Next up: [[3. Problem-solving Performance]]